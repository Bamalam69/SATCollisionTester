import graphics as g
from SATCollision import BoundingBox, IntersectTester, Vector2

# Declaring width and height of window
WIDTH = 500
HEIGHT = 500

# Making the window for entities to be drawn to.
window = g.GraphWin("Graphics Test", WIDTH, HEIGHT)

# Quick function for converting a Vector2 object to a g.Point object.
def ToPoint(vec2):
    return g.Point(vec2.x, vec2.y)

# Allowing the user to draw the first shape.

firstShape = []
finishedDrawingShape = False

while not finishedDrawingShape:
    try:
        recentPoint = window.getMouse()
    except g.GraphicsError:
        break

    if len(firstShape) >= 3:
        if Vector2.from_type(recentPoint).distance_from(firstShape[0]) <= 10:
            firstShape.append(firstShape[0])
            finishedDrawingShape = True

    if not finishedDrawingShape:
        firstShape.append(recentPoint)
        recentPoint.draw(window)

    if len(firstShape) >= 2:
        p1 = firstShape[-2]
        p2 = firstShape[-1]
        g.Line(p1, p2).draw(window)

if window.isClosed():
    exit(-1)

# get top of shape using the bounds generated by my library :D...
bounds1 = BoundingBox.generate_bounds_from([(point.x, point.y) for point in firstShape])
topPoint1 = g.Point(bounds1.x + (bounds1.width / 2), bounds1.y - 10)
# Drawing text signifying that this shape is the first shape.
g.Text(topPoint1, "Shape #1").draw(window)

# Converting the list of Vector2's that are the corners of the bounds, to a list of g.Point's.
bounds1Points = [g.Point(v.x, v.y) for v in  bounds1.corners()]

# Drawing the first shape as the graphics object "Polygon"
bounds1_polygon = g.Polygon(bounds1Points).draw(window)
bounds1_polygon.setOutline("blue")

# Allowing the user to draw the second shape.
finishedDrawingShape = False
secondShape = []

while finishedDrawingShape is not True:
    try:
        recentPoint = window.getMouse()
    except g.GraphicsError:
        break

    if len(secondShape) >= 3:
        if Vector2.from_type(recentPoint).distance_from(secondShape[0]) <= 10:
            secondShape.append(secondShape[0])
            finishedDrawingShape = True

    if not finishedDrawingShape:
        secondShape.append(recentPoint)
        recentPoint.draw(window)

    if len(secondShape) >= 2:
        p1 = secondShape[-2]
        p2 = secondShape[-1]
        g.Line(p1, p2).draw(window)

if window.isClosed():
    exit(-1)

# Generating the bounds for this shape. Will be used later to calculate positions for other things.
bounds2 = BoundingBox.generate_bounds_from(secondShape)

# Displaying text to show that this shape is the second shape, above the shape.
topPoint2 = g.Point(bounds2.x + (bounds2.width / 2), bounds2.y - 10)
g.Text(topPoint2, "Shape #2").draw(window)

# Converting returned list of Vector2's to list of g.Points.
bounds2Points = [g.Point(v.x, v.y) for v in  bounds2.corners()]

# Drawing the drawn shape as the graphics object "Polygon"
bounds2_drawable = g.Polygon(bounds2Points).draw(window)
bounds2_drawable.setOutline("red")

# Setting up a variable to be used as the display message
displayStringAABB = ""

# Displaying AABB check results.
if IntersectTester(firstShape, secondShape).test_minor():
    displayStringAABB += "AABB: Shapes are intersecting!"
else:
    displayStringAABB += "AABB: Shapes are NOT intersecting!"
aabbtext = g.Text(g.Point(WIDTH / 2, HEIGHT - 30), displayStringAABB).draw(window)
aabbtext.setTextColor("green")

# Displaying SAT Algorithm results along with MTV arrow.
displayStringSAT = ""
satresult = IntersectTester(firstShape, secondShape).test_major()
if satresult.intersecting:
    displayStringSAT = "SAT: Shapes are intersecting!"
    boundsCenter = bounds2.get_center()
    p1 = ToPoint(boundsCenter)
    mtvArrow = g.Line(p1, g.Point(p1.x + satresult.mtv.x, p1.y +  satresult.mtv.y))
    mtvArrow.draw(window)
    mtvArrow.setArrow("last")
    mtvArrow.setOutline("green")
else:
    displayStringSAT = "SAT: Shapes are NOT intersecting!"
sattext = g.Text(g.Point(WIDTH / 2, HEIGHT - 10), displayStringSAT).draw(window)
sattext.setTextColor("red")

# Waiting for user mouse input to close program / end execution.
try:
    window.getMouse()
except g.GraphicsError:
    pass
