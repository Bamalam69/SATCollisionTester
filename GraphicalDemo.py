import graphics as g
from SATCollision import BoundingBox, IntersectTester


WIDTH = 500
HEIGHT = 500


def distanceBetween(point1, point2):
    deltaPoint = g.Point(point1.x - point2.x, point1.y - point2.y)
    from math import sqrt
    return sqrt((deltaPoint.x ** 2) + (deltaPoint.y ** 2))

window = g.GraphWin("Graphics Test", WIDTH, HEIGHT)

firstShape = []
finishedDrawingShape = False

# Allowing the user to draw the first shape.

while not finishedDrawingShape:
    try:
        recentPoint = window.getMouse()
    except g.GraphicsError:
        break

    if len(firstShape) >= 3:
        if distanceBetween(recentPoint, firstShape[0]) <= 10:
            firstShape.append(firstShape[0])
            finishedDrawingShape = True

    if not finishedDrawingShape:
        firstShape.append(recentPoint)
        recentPoint.draw(window)

    if len(firstShape) >= 2:
        p1 = firstShape[-2]
        p2 = firstShape[-1]
        g.Line(p1, p2).draw(window)

if window.isClosed():
    exit(-1)

normals = IntersectTester._get_normals_from([(point.x, point.y) for point in firstShape])
for i in range(len(firstShape) - 1):
    if i + 1 >= len(firstShape):
        axis = g.Line(firstShape[i], firstShape[0])
    else:
        axis = g.Line(firstShape[i], firstShape[i + 1])

    normalObject = g.Line(g.Point(axis.getCenter().x - normals[i].x * 20, axis.getCenter().y - normals[i].y * 20),
                          g.Point(axis.getCenter().x + normals[i].x * 20, axis.getCenter().y + normals[i].y * 20))
    normalObject.setArrow("both")
    normalObject.setOutline("purple")
    normalObject.draw(window)

# get top of shape using the bounds generated by my library :D...

bounds1 = BoundingBox.generate_bounds_from([(point.x, point.y) for point in firstShape])
topPoint1 = g.Point(bounds1.x + (bounds1.width / 2), bounds1.y - 10)
g.Text(topPoint1, "Shape 1").draw(window)

bounds1Points = [g.Point(bounds1.x, bounds1.y), g.Point(bounds1.x + bounds1.width, bounds1.y),
                 g.Point(bounds1.x + bounds1.width, bounds1.y + bounds1.height), g.Point(bounds1.x, bounds1.y + bounds1.height),
                 g.Point(bounds1.x, bounds1.y)]

bounds1_polygon = g.Polygon(bounds1Points).draw(window)
bounds1_polygon.setOutline("blue")

# Allowing the user to draw the second shape.

finishedDrawingShape = False
secondShape = []

while finishedDrawingShape is not True:
    try:
        recentPoint = window.getMouse()
    except g.GraphicsError:
        break

    if len(secondShape) >= 3:
        if distanceBetween(recentPoint, secondShape[0]) <= 10:
            secondShape.append(secondShape[0])
            finishedDrawingShape = True

    if not finishedDrawingShape:
        secondShape.append(recentPoint)
        recentPoint.draw(window)

    if len(secondShape) >= 2:
        p1 = secondShape[-2]
        p2 = secondShape[-1]
        g.Line(p1, p2).draw(window)

if window.isClosed():
    exit(-1)

normals = IntersectTester._get_normals_from([(point.x, point.y) for point in secondShape])
for i in range(len(secondShape) - 1):
    axis = g.Line(secondShape[i], secondShape[i + 1])

    normalObject = g.Line(g.Point(axis.getCenter().x - normals[i].x * 20, axis.getCenter().y - normals[i].y * 20),
                          g.Point(axis.getCenter().x + normals[i].x * 20, axis.getCenter().y + normals[i].y * 20))
    normalObject.setArrow("both")
    normalObject.setOutline("purple")
    normalObject.draw(window)

bounds2 = BoundingBox.generate_bounds_from([(point.x, point.y) for point in secondShape])

topPoint2 = g.Point(bounds2.x + (bounds2.width / 2), bounds2.y - 10)
g.Text(topPoint2, "Shape 2").draw(window)

bounds2Points = [g.Point(bounds2.x, bounds2.y), g.Point(bounds2.x + bounds2.width, bounds2.y),
                 g.Point(bounds2.x + bounds2.width, bounds2.y + bounds2.height), g.Point(bounds2.x, bounds2.y + bounds2.height),
                 g.Point(bounds2.x, bounds2.y)]

bounds2_drawable = g.Polygon(bounds2Points).draw(window)
bounds2_drawable.setOutline("red")

firstShapeAsTuples = [(point.x, point.y) for point in firstShape]
secondShapeAsTuples = [(point.x, point.y) for point in secondShape]
displayStringAABB = ""

if IntersectTester(firstShapeAsTuples, secondShapeAsTuples).test_minor():
    displayStringAABB += "AABB: Shapes are intersecting!"
else:
    displayStringAABB += "AABB: Shapes are NOT intersecting!"
aabbtext = g.Text(g.Point(WIDTH / 2, HEIGHT - 30), displayStringAABB).draw(window)
aabbtext.setTextColor("green")

displayStringSAT = ""
satresult = IntersectTester(firstShapeAsTuples, secondShapeAsTuples).test_major()
if satresult.intersecting:
    displayStringSAT = "SAT: Shapes are intersecting!"
    p1 = g.Point(bounds2.x + (bounds2.width / 2), bounds2.y + (bounds2.height / 2))
    mtvArrow = g.Line(p1, g.Point((WIDTH / 2) + satresult.mtv.x * 10, (HEIGHT / 2) +  satresult.mtv.y * 10))
    mtvArrow.draw(window)
    mtvArrow.setArrow("last")
    print(satresult.mtv)
else:
    displayStringSAT = "SAT: Shapes are NOT intersecting!"

sattext = g.Text(g.Point(WIDTH / 2, HEIGHT - 10), displayStringSAT).draw(window)
sattext.setTextColor("red")

try:
    window.getMouse()
except g.GraphicsError:
    pass
